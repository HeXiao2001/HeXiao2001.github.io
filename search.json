[{"title":"matplotlib绘制三维散点图，并添加包围椭球及各维度核密度","path":"/2024/12/02/matplotlib绘制三维散点图/","content":"背景我们在绘制三维散点时经常需要在一张图中描述：1.散点在空间中的分布状态；2.散点在空间不同维度的分布情况。下面介绍一种：通过椭球描述散点在空间中的分布状态，并通过核密度曲线描述散点在空间不同维度的分布情况的方法。 实现导入必要的库，数据准备import matplotlib.pyplot as pltimport numpy as npfrom scipy.stats import gaussian_kde # 导入高斯核函数 创建3D图ax &#x3D; plt.figure().add_subplot(projection&#x3D;’3d’)data&#x3D;[] 随机生成data定义一个函数来生成数据def generate_data(mean, std_dev): return np.random.normal(mean, std_dev, 100)data.append(generate_data(0.8, 0.1))data.append(generate_data(15, 2))data.append(generate_data(60, 10)) 显示散点图的包围椭球matplotlib中需要构造点阵以显示面，因此我们需要首先生成椭球面的XYZ坐标，然后绘制 def draw_ellipsoid(ax, data, color): # 计算椭球的中心 center &#x3D; np.mean(data, axis&#x3D;1) # 计算椭球的半径 radius = 0.5 * (np.max(data, axis=1) - np.min(data, axis=1)) # 生成椭球的表面点 u = np.linspace(0, 2 * np.pi, 100) v = np.linspace(0, np.pi, 100) x = center[0] + radius[0] * np.outer(np.cos(u), np.sin(v)) y = center[1] + radius[1] * np.outer(np.sin(u), np.sin(v)) z = center[2] + radius[2] * np.outer(np.ones(np.size(u)), np.cos(v)) # 绘制椭球 ax.plot_surface(x, y, z, color=color, alpha=0.2) 显示散点在空间不同维度的分布情况matplotlib的官网实例中提到，可以采用zdir 字段实现2D内容在3D图上的绘制，这里实际上可以简单将zdir设置为2D图中“缺失的”那个维度，如下所示 在X-Z平面上绘制核密度估计图def draw_kde3d_X2XZ(ax, data, color): kde &#x3D; gaussian_kde(data) xs &#x3D; np.linspace(np.min(data), np.max(data), 100) ys &#x3D; kde(xs) ax.plot(xs, ys10, zs&#x3D;0, zdir&#x3D;’y’, color&#x3D;color)在Y-Z平面上绘制核密度估计图def draw_kde3d_Y2YZ(ax, data, color): kde &#x3D; gaussian_kde(data) xs &#x3D; np.linspace(np.min(data), np.max(data), 100) ys &#x3D; kde(xs) ax.plot(xs,ys100, zs&#x3D;[1.2 for _ in range(len(data))], zdir&#x3D;’x’, color&#x3D;color)在Z-Y平面上绘制核密度估计图def draw_kde3d_Z2ZY(ax, data, color): kde &#x3D; gaussian_kde(data) xs &#x3D; np.linspace(np.min(data), np.max(data), 100) ys &#x3D; kde(xs) ax.plot(ys*80,xs, zs&#x3D;0, zdir&#x3D;’x’, color&#x3D;color) 其实这里zdir其实就是与我们要绘制的平面相垂直的坐标轴，zdir在这里起到了“临时更换坐标轴”的作用。 全部代码import matplotlib.pyplot as pltimport numpy as npfrom scipy.stats import gaussian_kde 创建3D图ax &#x3D; plt.figure().add_subplot(projection&#x3D;’3d’)data&#x3D;[] 随机生成data定义一个函数来生成数据def generate_data(mean, std_dev): return np.random.normal(mean, std_dev, 100)data.append(generate_data(0.8, 0.1))data.append(generate_data(15, 2))data.append(generate_data(60, 10)) def draw_ellipsoid(ax, data, color): # 计算椭球的中心 center &#x3D; np.mean(data, axis&#x3D;1) # 计算椭球的半径 radius &#x3D; 0.5 * (np.max(data, axis&#x3D;1) - np.min(data, axis&#x3D;1)) # 生成椭球的表面点 u &#x3D; np.linspace(0, 2 * np.pi, 100) v &#x3D; np.linspace(0, np.pi, 100) x &#x3D; center[0] + radius[0] * np.outer(np.cos(u), np.sin(v)) y &#x3D; center[1] + radius[1] * np.outer(np.sin(u), np.sin(v)) z &#x3D; center[2] + radius[2] * np.outer(np.ones(np.size(u)), np.cos(v)) # 绘制椭球 ax.plot_surface(x, y, z, color&#x3D;color, alpha&#x3D;0.2) 在X-Z平面上绘制核密度估计图def draw_kde3d_X2XZ(ax, data, color): kde &#x3D; gaussian_kde(data) xs &#x3D; np.linspace(np.min(data), np.max(data), 100) ys &#x3D; kde(xs) ax.plot(xs, ys*10, zs&#x3D;0, zdir&#x3D;’y’, color&#x3D;color) 在Y-Z平面上绘制核密度估计图def draw_kde3d_Y2YZ(ax, data, color): kde &#x3D; gaussian_kde(data) xs &#x3D; np.linspace(np.min(data), np.max(data), 100) ys &#x3D; kde(xs) ax.plot(xs,ys*100, zs&#x3D;[1.2 for _ in range(len(data))], zdir&#x3D;’x’, color&#x3D;color) 在Z-Y平面上绘制核密度估计图def draw_kde3d_Z2ZY(ax, data, color): kde &#x3D; gaussian_kde(data) xs &#x3D; np.linspace(np.min(data), np.max(data), 100) ys &#x3D; kde(xs) ax.plot(ys*80,xs, zs&#x3D;0, zdir&#x3D;’x’, color&#x3D;color) xyzlims&#x3D;(0, 1.2, 0, 22, 0, 105)绘制散点图ax.scatter(data[0], data[1], data[2], c&#x3D;’g’, marker&#x3D;’*’, s&#x3D;10, label&#x3D;’data’)绘制椭球draw_ellipsoid(ax, data, ‘g’)绘制X轴方向的核密度估计draw_kde3d_X2XZ(ax, data[0], ‘g’)绘制Y轴方向的核密度估计draw_kde3d_Y2YZ(ax, data[1], ‘g’)绘制Z轴方向的核密度估计draw_kde3d_Z2ZY(ax, data[2], ‘g’)ax.set(xlim&#x3D;(0, 1.2), ylim&#x3D;(0, 22), zlim&#x3D;(0, 105))Set zoom and angle viewax.view_init(20, -35, 0)ax.set_box_aspect(None, zoom&#x3D;1)设置坐标轴的网格线颜色ax.xaxis.pane.set_edgecolor((1.0, 1.0, 1.0, 0.0))ax.yaxis.pane.set_edgecolor((1.0, 1.0, 1.0, 0.0))ax.zaxis.pane.set_edgecolor((1.0, 1.0, 1.0, 0.0))ax.set_xlabel(‘X’)ax.set_ylabel(‘Y’)ax.set_zlabel(‘Z’)plt.show() 实现效果 一点小改进有些时候，我们可能有多种数据需要进行比较。这时，坐标系、网格等元素会对我们的展示造成干扰。因此，这里可以关闭这些内容的显示，并使用立方体表示三维空间。 def showbox(data,ax): x, y, z &#x3D; 0,0,0 #盒子坐标 dx, dy, dz &#x3D; data #盒子长、宽、高 ax.bar3d(x, y, z, dx, dy, dz, color&#x3D;”green”,zsort&#x3D;’average’,edgecolor&#x3D;’black’,linewidth&#x3D;1,alpha&#x3D;0) ···其他代码··· 设置坐标轴的背景颜色ax.xaxis.pane.fill &#x3D; Falseax.yaxis.pane.fill &#x3D; Falseax.zaxis.pane.fill &#x3D; False设置坐标轴不可见ax.axis(‘off’)ax.grid(False)设置坐标轴的网格线颜色ax.xaxis.pane.set_edgecolor((1.0, 1.0, 1.0, 0.0))ax.yaxis.pane.set_edgecolor((1.0, 1.0, 1.0, 0.0))ax.zaxis.pane.set_edgecolor((1.0, 1.0, 1.0, 0.0))关闭坐标轴的刻度ax.set_xticks([])ax.set_yticks([])ax.set_zticks([])box &#x3D; (1.2,22,105)显示立方体showbox(box,ax)ax.set_xlabel(‘X’)ax.set_ylabel(‘Y’)ax.set_zlabel(‘Z’)plt.show() 最终效果"},{"title":"Hello World","path":"/2024/12/02/hello-world/","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment"}]