[{"title":"Clash Verge 订阅规则扩展：避免学术网站走代理","url":"/2024/12/02/clash%E8%AE%A2%E9%98%85%E8%A7%84%E5%88%99%E6%89%A9%E5%B1%95/","content":"在校内访问学术网站是不需要代理的，如果通过代理的话每次都会弹出学校账户验证很麻烦，因此有必要将学术网站的访问设置为直连（即不通过代理）右键订阅点编辑规则–高级\n点击高级\n将里面的代码替换为下面的代码就好了\nprepend:  - &#x27;DOMAIN,tuchong.com,DIRECT&#x27;  - &#x27;DOMAIN-SUFFIX,taylorandfrancis.com,DIRECT&#x27;  - &#x27;DOMAIN,dl.acm.org,DIRECT&#x27;  - &#x27;DOMAIN,acm-prod.disqus.com,DIRECT&#x27;  - &#x27;DOMAIN-SUFFIX,sciencedirectassets.com,DIRECT&#x27;  - &#x27;DOMAIN-SUFFIX,readspeaker.com,DIRECT&#x27;  - &#x27;DOMAIN-SUFFIX,webofknowledge.com,DIRECT&#x27;  - &#x27;DOMAIN-KEYWORD,pubmed,DIRECT&#x27;  - &#x27;DOMAIN-KEYWORD,springer,DIRECT&#x27;  - &#x27;DOMAIN-KEYWORD,ieee,DIRECT&#x27;  - &#x27;DOMAIN-KEYWORD,elsevier,DIRECT&#x27;  - &#x27;DOMAIN-KEYWORD,sciencedirect,DIRECT&#x27;  - &#x27;DOMAIN-KEYWORD,nature,DIRECT&#x27;  - &#x27;DOMAIN-KEYWORD,tandfonline,DIRECT&#x27;  - &#x27;DOMAIN-SUFFIX,elsevier.com,DIRECT&#x27;  - &#x27;DOMAIN-SUFFIX,edu.cn,DIRECT&#x27;  - &#x27;DOMAIN-SUFFIX,webofscience.com,DIRECT&#x27;  - &#x27;DOMAIN-SUFFIX,tandfonline.com,DIRECT&#x27;  - &#x27;DOMAIN-SUFFIX,link.springer.com,DIRECT&#x27;  - &#x27;DOMAIN-SUFFIX,onlinelibrary.wiley.com,DIRECT&#x27;  - &#x27;DOMAIN-SUFFIX,sciencedirect.com,DIRECT&#x27;  - &#x27;DOMAIN-SUFFIX,taylorfrancis.com,DIRECT&#x27;append: []delete: []","categories":["technique","vpn"],"tags":["Blogs","vpn"]},{"title":"Matplotlib 绘制三维散点图与包围椭球及核密度分析","url":"/2024/12/02/matplotlib%E7%BB%98%E5%88%B6%E4%B8%89%E7%BB%B4%E6%95%A3%E7%82%B9%E5%9B%BE/","content":"背景我们在绘制三维散点时经常需要在一张图中描述：1.散点在空间中的分布状态；2.散点在空间不同维度的分布情况。下面介绍一种：通过椭球描述散点在空间中的分布状态，并通过核密度曲线描述散点在空间不同维度的分布情况的方法。\n实现导入必要的库，数据准备\nimport matplotlib.pyplot as pltimport numpy as npfrom scipy.stats import gaussian_kde  # 导入高斯核函数\n\n创建3D图ax = plt.figure().add_subplot(projection=&#x27;3d&#x27;)data=[]\n随机生成data定义一个函数来生成数据\ndef generate_data(mean, std_dev):    return np.random.normal(mean, std_dev, 100)data.append(generate_data(0.8, 0.1))data.append(generate_data(15, 2))data.append(generate_data(60, 10))\n显示散点图的包围椭球matplotlib中需要构造点阵以显示面，因此我们需要首先生成椭球面的XYZ坐标，然后绘制\ndef draw_ellipsoid(ax, data, color):    # 计算椭球的中心    center = np.mean(data, axis=1)    # 计算椭球的半径    radius = 0.5 * (np.max(data, axis=1) - np.min(data, axis=1))    # 生成椭球的表面点    u = np.linspace(0, 2 * np.pi, 100)    v = np.linspace(0, np.pi, 100)    x = center[0] + radius[0] * np.outer(np.cos(u), np.sin(v))    y = center[1] + radius[1] * np.outer(np.sin(u), np.sin(v))    z = center[2] + radius[2] * np.outer(np.ones(np.size(u)), np.cos(v))    # 绘制椭球    ax.plot_surface(x, y, z, color=color, alpha=0.2)\n显示散点在空间不同维度的分布情况matplotlib的官网实例中提到，可以采用zdir 字段实现2D内容在3D图上的绘制，这里实际上可以简单将zdir设置为2D图中“缺失的”那个维度，如下所示\n在X-Z平面上绘制核密度估计图\ndef draw_kde3d_X2XZ(ax, data,  color):    kde = gaussian_kde(data)    xs = np.linspace(np.min(data), np.max(data), 100)    ys = kde(xs)    ax.plot(xs, ys*10, zs=0, zdir=&#x27;y&#x27;, color=color)\n在Y-Z平面上绘制核密度估计图\ndef draw_kde3d_Y2YZ(ax, data,  color):    kde = gaussian_kde(data)    xs = np.linspace(np.min(data), np.max(data), 100)    ys = kde(xs)    ax.plot(xs,ys*100,  zs=[1.2 for _ in range(len(data))], zdir=&#x27;x&#x27;, color=color)\n在Z-Y平面上绘制核密度估计图\ndef draw_kde3d_Z2ZY(ax, data,  color):    kde = gaussian_kde(data)    xs = np.linspace(np.min(data), np.max(data), 100)    ys = kde(xs)    ax.plot(ys*80,xs,  zs=0, zdir=&#x27;x&#x27;, color=color)\n\n其实这里zdir其实就是与要绘制的平面相垂直的坐标轴，zdir在这里起到“临时更换坐标轴”的作用。\n全部代码\nimport matplotlib.pyplot as pltimport numpy as npfrom scipy.stats import gaussian_kde\n\n创建3D图ax = plt.figure().add_subplot(projection=&#x27;3d&#x27;)data=[]\n\n随机生成datadef generate_data(mean, std_dev):    return np.random.normal(mean, std_dev, 100)data.append(generate_data(0.8, 0.1))data.append(generate_data(15, 2))data.append(generate_data(60, 10))def draw_ellipsoid(ax, data, color):    # 计算椭球的中心    center = np.mean(data, axis=1)    # 计算椭球的半径    radius = 0.5 * (np.max(data, axis=1) - np.min(data, axis=1))    # 生成椭球的表面点    u = np.linspace(0, 2 * np.pi, 100)    v = np.linspace(0, np.pi, 100)    x = center[0] + radius[0] * np.outer(np.cos(u), np.sin(v))    y = center[1] + radius[1] * np.outer(np.sin(u), np.sin(v))    z = center[2] + radius[2] * np.outer(np.ones(np.size(u)), np.cos(v))    # 绘制椭球    ax.plot_surface(x, y, z, color=color, alpha=0.2)\n\n在X-Z平面上绘制核密度估计图def draw_kde3d_X2XZ(ax, data,  color):    kde = gaussian_kde(data)    xs = np.linspace(np.min(data), np.max(data), 100)    ys = kde(xs)    ax.plot(xs, ys*10, zs=0, zdir=&#x27;y&#x27;, color=color)\n\n在Y-Z平面上绘制核密度估计图def draw_kde3d_Y2YZ(ax, data,  color):    kde = gaussian_kde(data)    xs = np.linspace(np.min(data), np.max(data), 100)    ys = kde(xs)    ax.plot(xs,ys*100,  zs=[1.2 for _ in range(len(data))], zdir=&#x27;x&#x27;, color=color)\n\n在Z-Y平面上绘制核密度估计图def draw_kde3d_Z2ZY(ax, data,  color):    kde = gaussian_kde(data)    xs = np.linspace(np.min(data), np.max(data), 100)    ys = kde(xs)    ax.plot(ys*80,xs,  zs=0, zdir=&#x27;x&#x27;, color=color)\n\n\n\nxyzlims=(0, 1.2, 0, 22, 0, 105)\n\n绘制散点图ax.scatter(data[0], data[1], data[2], c&#x3D;’g’, marker&#x3D;’*’, s&#x3D;10, label&#x3D;’data’)\n绘制椭球\ndraw_ellipsoid(ax, data, &#x27;g&#x27;)\n\n绘制X轴方向的核密度估计\ndraw_kde3d_X2XZ(ax, data[0], &#x27;g&#x27;)\n\n绘制Y轴方向的核密度估计\ndraw_kde3d_Y2YZ(ax, data[1], &#x27;g&#x27;)\n\n绘制Z轴方向的核密度估计\ndraw_kde3d_Z2ZY(ax, data[2], &#x27;g&#x27;)ax.set(xlim=(0, 1.2), ylim=(0, 22), zlim=(0, 105))Set zoom and angle viewax.view_init(20, -35, 0)ax.set_box_aspect(None, zoom=1)\n\n设置坐标轴的网格线颜色\nax.xaxis.pane.set_edgecolor((1.0, 1.0, 1.0, 0.0))ax.yaxis.pane.set_edgecolor((1.0, 1.0, 1.0, 0.0))ax.zaxis.pane.set_edgecolor((1.0, 1.0, 1.0, 0.0))ax.set_xlabel(&#x27;X&#x27;)ax.set_ylabel(&#x27;Y&#x27;)ax.set_zlabel(&#x27;Z&#x27;)plt.show()\n\n实现效果\n一点小改进有些时候，我们可能有多种数据需要进行比较。这时，坐标系、网格等元素会对我们的展示造成干扰。因此，这里可以关闭这些内容的显示，并使用立方体表示三维空间。\ndef showbox(data,ax):      x, y, z = 0,0,0  #盒子坐标    dx, dy, dz = data  #盒子长、宽、高    ax.bar3d(x, y, z, dx, dy, dz, color=&quot;green&quot;,zsort=&#x27;average&#x27;,edgecolor=&#x27;black&#x27;,linewidth=1,alpha=0)···其他代码···\n\n设置坐标轴的背景颜色\nax.xaxis.pane.fill = Falseax.yaxis.pane.fill = Falseax.zaxis.pane.fill = False\n\n设置坐标轴不可见\nax.axis(&#x27;off&#x27;)ax.grid(False)\n\n设置坐标轴的网格线颜色\nax.xaxis.pane.set_edgecolor((1.0, 1.0, 1.0, 0.0))ax.yaxis.pane.set_edgecolor((1.0, 1.0, 1.0, 0.0))ax.zaxis.pane.set_edgecolor((1.0, 1.0, 1.0, 0.0))\n\n关闭坐标轴的刻度\nax.set_xticks([])ax.set_yticks([])ax.set_zticks([])box = (1.2,22,105)\n\n显示立方体\nshowbox(box,ax)ax.set_xlabel(&#x27;X&#x27;)ax.set_ylabel(&#x27;Y&#x27;)ax.set_zlabel(&#x27;Z&#x27;)plt.show()\n\n\n最终效果\n","categories":["technique"],"tags":["Blogs","plot","python"]},{"title":"Clash 全局扩展脚本：智能控制网站代理访问","url":"/2024/12/24/clash%E5%85%A8%E5%B1%80%E6%89%A9%E5%B1%95%E8%84%9A%E6%9C%AC%E9%98%B2%E6%AD%A2%E9%83%A8%E5%88%86%E7%BD%91%E7%AB%99%E4%BD%BF%E7%94%A8%E4%BB%A3%E7%90%86%E8%AE%BF%E9%97%AE/","content":"这是对上篇博客的更新 clash verge 订阅扩展规则，防止部分学术网站走代理。上篇博客中的解决方案存在一个问题：每个订阅都需要设置一次，为了更加方便地将设置应用到全部订阅中，可以在clash verge 全局扩展脚本中设置代码\n步骤：\n\n打开clash verge \n点击订阅，右键全局扩展配置，点击编辑文件\n将下方的代码替换进去\n最后，请记得更新所有订阅以应用这项更改\n\n// Define main function (script entry) function main(config, profileName) &#123;  // 根据名称排除节点  config = removeNodeByName(config, /[kK]onghwaguk/g);  // 新增：为美国、台湾、新加坡节点创建 AI 代理组  config = addAITestGroup(config);  // 添加代理规则  config = addProxyRules(config);  // 添加直连规则  config = addDirectRules(config);  return config;&#125;function addAITestGroup(config) &#123;  if (!config[&#x27;proxy-groups&#x27;] || !config.proxies) return config;  // 收集包含“美国”/“台湾”/“新加坡”关键词的节点  const aiNodes = config.proxies.filter(p =&gt;    p.name &amp;&amp; /(美国|usa|united\\s?states|台湾|taiwan|新加坡|singapore)/i.test(p.name)  ).map(p =&gt; p.name);  const groupIndex = config[&#x27;proxy-groups&#x27;].findIndex(g =&gt; g.name === &#x27;AI代理组&#x27;);  if (groupIndex !== -1) &#123;    config[&#x27;proxy-groups&#x27;][groupIndex].proxies = aiNodes;  &#125; else &#123;    config[&#x27;proxy-groups&#x27;].push(&#123;      name: &#x27;AI代理组&#x27;,      type: &#x27;url-test&#x27;,      proxies: aiNodes,      url: &#x27;http://www.gstatic.com/generate_204&#x27;,      interval: 500    &#125;);  &#125;  return config;&#125;/*** * 根据名称排除节点 */function removeNodeByName(config, regExp) &#123;  config[&#x27;proxy-groups&#x27;] = config[&#x27;proxy-groups&#x27;].map(it =&gt; &#123;    it.proxies = it.proxies.filter(name =&gt; !name.match(regExp));    return it;  &#125;);  return config;&#125;/*** * 添加代理规则 */function addProxyRules(config) &#123;  config.rules = myProxyRules.concat(config.rules);  return config;&#125;/*** * 添加直连规则 */function addDirectRules(config) &#123;  config.rules = myDirectRules.concat(config.rules);  return config;&#125;/*** * 自定义代理规则 */const myProxyRules = [  &quot;DOMAIN-SUFFIX,openai.com,AI代理组&quot;,  &quot;DOMAIN-SUFFIX,anthropic.com,AI代理组&quot;,  &quot;DOMAIN-KEYWORD,claude,AI代理组&quot;,  &quot;DOMAIN-KEYWORD,chatgpt,AI代理组&quot;,  &quot;DOMAIN-KEYWORD,generativelanguage,AI代理组&quot;,  &quot;DOMAIN-KEYWORD,arcgis,AI代理组&quot;,  &quot;DOMAIN-KEYWORD,google,AI代理组&quot;,];/*** * 自定义直连规则 */const myDirectRules = [  &quot;DOMAIN-KEYWORD,pubmed,DIRECT&quot;,  &quot;DOMAIN-KEYWORD,springer,DIRECT&quot;,  &quot;DOMAIN-KEYWORD,ieee,DIRECT&quot;,  &quot;DOMAIN-KEYWORD,elsevier,DIRECT&quot;,  &quot;DOMAIN-KEYWORD,steam,DIRECT&quot;,  &quot;DOMAIN-KEYWORD,clarivate,DIRECT&quot;,  &quot;DOMAIN-KEYWORD,sciencedirect,DIRECT&quot;,  &quot;DOMAIN-KEYWORD,webofscience,DIRECT&quot;,  &quot;DOMAIN-KEYWORD,nature,DIRECT&quot;,  &quot;DOMAIN-KEYWORD,tandfonline,DIRECT&quot;,  &quot;DOMAIN-KEYWORD,taylorfrancis,DIRECT&quot;,  &quot;DOMAIN-KEYWORD,cherrystudio,DIRECT&quot;,  &quot;DOMAIN-KEYWORD,taylorandfrancis,DIRECT&quot;,  &quot;DOMAIN-KEYWORD,elsevier.com,DIRECT&quot;,           // 保持，即使它看起来像一个域名  &quot;DOMAIN-KEYWORD,onlinelibrary.wiley.com,DIRECT&quot;, // 保持，即使它看起来像一个域名  &quot;DOMAIN-KEYWORD,els-cdn.com,DIRECT&quot;,            // 保持，即使它看起来像一个域名  &quot;DOMAIN-KEYWORD,tuchong.com,DIRECT&quot;,            // 保持，即使它看起来像一个域名  &quot;DOMAIN-KEYWORD,dl.acm.org,DIRECT&quot;,              // 保持，即使它看起来像一个域名  &quot;DOMAIN-KEYWORD,acm-prod.disqus.com,DIRECT&quot;,    // 保持，即使它看起来像一个域名  &quot;DOMAIN-KEYWORD,readspeaker.com,DIRECT&quot;,        // 保持，即使它看起来像一个域名  &quot;DOMAIN-KEYWORD,webofknowledge.com,DIRECT&quot;,      // 保持，即使它看起来像一个域名  &quot;DOMAIN-KEYWORD,taylorfrancis.com,DIRECT&quot;,      // 保持，即使它看起来像一个域名  &quot;DOMAIN-KEYWORD,tandfonline.com,DIRECT&quot;,        // 保持，即使它看起来像一个域名  &quot;DOMAIN-KEYWORD,rp.tandfonline.com,DIRECT&quot;,      // 保持，即使它看起来像一个域名];","categories":["technique","vpn"],"tags":["Blogs","vpn"]},{"title":"HEProOE: Hyperedge-Enhanced Spatial Community Detection Method","url":"/2025/11/17/HEProOE/","content":"Building upon our previous work with ProOE, we are thrilled to introduce the Hyperedge-Enhanced Probabilistic Optimal Estimation (HEProOE) method. This advanced model addresses a key limitation in mobility-based community detection: the fragmentation of large, semantically consistent areas. HEProOE integrates hyperedges to represent these “Indivisible Regions” (IRs), ensuring that the detected communities are not only structurally sound but also functionally coherent.\n\nPaper: HEProOE: A hyperedge enhanced probabilistic optimal estimation method for detecting spatial fuzzy communities.\nGitHub Repository: The data and code can be requested from me.\n\n\nAbstractIdentifying spatial communities with human mobility data has emerged as a key approach to understanding urban spatial structure. However, relying solely on human mobility data to partition spatial communities ignores the semantic information and may fragment large, semantic consistent Indivisible Regions (IRs) such as college campuses. Furthermore, individual spatial units often belong simultaneously to multiple IRs, creating membership uncertainty, while the spatial stochasticity of human movements inherently introduces ambiguity to the boundaries of spatial fuzzy communities. To address these challenges, we proposed the Hyperedge-Enhanced Probabilistic Optimal Estimation method (HEProOE) that integrated the hyperedge into spatial fuzzy community detection, representing IRs as semantic consistent regions. First, IRs were represented as hyperedges, where each spatial unit holds a probabilistic community membership. Second, a novel distance-weighted Jensen-Shannon (JS) divergence metric was introduced to measure the semantic consistency within each hyperedge. Finally, this metric was converted into a new likelihood component and seamlessly integrated with the mobility-based ProOE model, yielding a unified framework that simultaneously optimizes for both mobility patterns and semantic consistency. Experimental results demonstrated that HEProOE uncovers spatial fuzzy communities with significantly higher semantic consistency, providing an effective tool for a more authentic understanding of urban spatial structures.\n\nThe Challenge: Beyond Mobility PatternsWhile models like ProOE excel at identifying fuzzy communities from mobility data, they can sometimes break apart functionally unified areas—like a large university campus or a financial district—because the internal mobility patterns might not be perfectly uniform. These Indivisible Regions (IRs) have a strong semantic identity that should be preserved.\nThe HEProOE Framework: Integrating Semantics with HyperedgesHEProOE solves this by introducing hyperedges. In network science, a regular edge connects two nodes. A hyperedge can connect multiple nodes at once. We use hyperedges to model IRs, grouping all spatial units within a single functional zone (e.g., all the zones that make up “Midtown”).\nThis creates a unified probabilistic framework that balances two goals:\n\nAligning with observed mobility patterns (the strength of ProOE).\nEnforcing semantic consistency within known IRs (the new enhancement).\n\nThe overall methodology is illustrated below.\n\n\nStudy Area and DataWe again use New York City as our study area. The IRs (hyperedges) were sourced from OpenStreetMap, selecting 18 prominent, named regions like “Upper West Side” and “Lenox Hill.” The mobility data comes from over 8 million taxi trips.\n\n\nKey Results: Semantically Consistent CommunitiesThe integration of hyperedges leads to a significant improvement in the quality and interpretability of the detected communities.\nVisual Comparison: ProOE vs. HEProOEThe figure below shows a direct comparison between the communities detected by the original ProOE and the new HEProOE. While ProOE identifies a reasonable structure, it incorrectly splits the well-defined “Upper West Side” and “Upper East Side” regions. HEProOE, guided by the semantic hyperedges, correctly preserves the integrity of these large functional zones.\nQuantitative EvaluationTo provide a quantitative basis for our comparison, we measured the alignment between each model’s community partitions and the predefined Identified Regions (IRs) using Fuzzy Normalized Mutual Information (FNMI)30. The results are telling: HEProOE achieved the highest FNMI score (0.440), surpassing both ProOE (0.410) and Hypergraph-MT (0.312). This score confirms that our model’s partitions correspond most closely to the city’s established semantic geography, a finding corroborated by visual analysis.\nBy combining the strengths of probabilistic modeling with the structural integrity of hypergraphs, HEProOE provides a powerful and more authentic tool for understanding the complex fabric of our cities.\n","categories":["Research","Methodology"],"tags":["News","Community Detection","Human Mobility","Fuzzy theory","Hypergraph","Urban Computing"]},{"title":"ProOE: Detecting Spatial Fuzzy Communities with Probabilistic Estimation","url":"/2025/04/05/ProOE/","content":"We are excited to introduce ProOE (Probabilistic Optimal Estimation), a novel approach for detecting spatial fuzzy communities, as detailed in our recent publication in the International Journal of Geographical Information Science. This method provides a more nuanced understanding of urban structures by embracing the inherent fuzziness and heterogeneity of human movements.\nYou can find the full paper and the source code here:\n\nPaper: A Probabilistic Optimal Estimation Method for Detecting Spatial Fuzzy Communities\nGitHub Repository: HeXiao2001&#x2F;ProOE\n\n\nAbstractUrban areas comprise numerous spatial communities due to the frequent and limited range of human movements. Due to the partial spatial stochasticity of human movements, urban spatial communities are fuzzy and spatially heterogeneous. Existing spatial community detection strategies based on deterministic and globally uniform criteria fail to account for these characteristics. Therefore, this study presents a framework for detecting spatial fuzzy communities by transforming spatial fuzzy community detection into trip estimations between spatial units. We developed a probabilistic optimal estimation (ProOE) method to estimate trip volumes between spatial units by adjusting the probability of the membership of each unit in a spatial community. A trip intensity parameter was introduced for each community to adjust the estimated trip volumes. The distance decay effect (DDE) of human movement was then incorporated into the model, further improving the accuracy of community delineation for specific cities. Finally, spatial continuity guidance was incorporated into the solution algorithm, minimizing unnecessary community fragmentation. The experimental results demonstrate that ProOE outperforms existing methods, achieving an average improvement of 31.57% in accuracy while effectively capturing the ambiguity in the interplay between spatial units and communities. This study contributes to a more precise understanding of the spatial structures of cities.\n\nA Quick Look at Existing MethodsTraditional spatial community detection methods often rely on deterministic and globally uniform criteria. However, these approaches fall short in capturing the fuzzy boundaries and spatial heterogeneity that characterize real-world urban movements.\nThe ProOE FrameworkOur ProOE method reframes the problem by transforming community detection into a trip estimation task between spatial units. The core idea is to probabilistically estimate trip volumes by iteratively adjusting the membership probabilities of each spatial unit to every community.\nThe framework is illustrated below, showing how ProOE integrates spatial constraints and probabilistic estimation to delineate fuzzy communities.\n\nThe core idea of the model is further detailed in the following illustration, which visualizes how membership probabilities are optimized.\n\n\nKey Results: Simulated &amp; Real-World DataTo validate the effectiveness of ProOE, we conducted experiments on both simulated and real-world datasets.\n1. Performance on Simulated DatasetsWe first designed three distinct simulated datasets to rigorously test the model’s ability to handle key spatial characteristics: continuity, fuzziness, and heterogeneity.\n\nThe results of various community detection methods on these datasets are visualized below. It is clear that traditional methods struggle to correctly identify community structures, especially in the presence of fuzzy boundaries and varied internal densities.\n\n\nTo quantify this, we used the Fuzzy Normalized Mutual Information (FNMI) metric, which measures the similarity between the detected fuzzy communities and the ground truth. A higher FNMI value indicates better accuracy. As shown below, ProOE consistently outperforms other state-of-the-art methods across all three datasets.\n\n\n2. Case Study: New York City Taxi TripsWe then applied ProOE to a real-world dataset of New York City taxi trips to explore urban mobility patterns. The study area focuses on Manhattan, a hub of intense and complex human movement.\n\nThe final community structure detected by ProOE reveals a clear and meaningful division of Manhattan. The detected communities correspond well with known functional zones, such as Midtown, Upper East Side, and the financial district in Lower Manhattan. The fuzzy boundaries between these communities highlight the transitional zones where urban functions blend.\n\n\nDemonstration VideoCheck out this video demonstrating the evolution of spatial fuzzy communities in New York City, generated using the ProOE method.\nThis work offers a powerful new lens for urban planners, geographers, and data scientists to analyze and understand the intricate spatial fabric of our cities. We welcome you to explore the code, run the demos, and contribute to this exciting area of research!\n","categories":["Research","Methodology"],"tags":["News","Community Detection","Human Mobility","Fuzzy theory","Urban Computing","Python"]},{"title":"Clash Verge 进阶玩法：双机场合并 + AI 专线精准分流指南","url":"/2025/11/19/clashvergeDubleMerge/","content":"\n背景需求：很多朋友手头都有两个机场订阅：\n\n主力机场（如pianyijichang）： 流量大、便宜，台湾&#x2F;香港节点速度快，适合看 YouTube、Netflix 和日常冲浪。\n备用&#x2F;高端机场（如 AIjichangCloud）： 拥有原生 IP，能解锁各种 AI 限制，适合专门访问 Google AI Studio、Gemini、OpenAI。\n\n痛点： 简单的合并订阅会导致节点混杂，如果不手动切换，AI 请求很容易走到台湾节点导致报错（如 Region not supported）。\n今天分享一个在 Clash Verge (Rev) 中实现“双订阅合并 + 自动化分流”的完美方案。\n\n第一步：创建本地配置，合并并标记节点要在脚本中区分两个机场，最稳妥的办法是在拉取订阅时给节点加上“前缀标签”。\n新建一个 Local 类型的配置，使用 proxy-providers 引入订阅，并利用 override 功能强行加前缀：\nproxy-providers:  # 机场 A：主力流量  pianyijichang:    type: http    url: &quot;你的订阅链接&quot;    path: ./profiles/pianyijichang.yaml    override:      additional-prefix: &quot;[pianyijichang]&quot; # 关键步骤：给它打上标签  # 机场 B：AI 专用  AIjichang:    type: http    url: &quot;你的订阅链接&quot;    path: ./profiles/AIjichang.yaml    override:      additional-prefix: &quot;[AIjichang]&quot;   # 关键步骤：给它打上标签\n\n第二步：使用脚本进行正则筛选在 Clash Verge 的 全局扩展脚本 中，利用正则表达式根据刚才的标签把节点分配给不同的策略组。\n核心逻辑：\n\nYouTube&#x2F;通用组：只允许名字里含 [pianyijichang] 的节点进入。\nAI 组：只允许名字里含 [AIjichang] 且含 美国 的节点进入。\n\n代码片段（修改 config[&quot;proxy-groups&quot;] 部分）：\n// YouTube 或 通用 策略组&#123;  &quot;name&quot;: &quot;YouTube&quot;,  &quot;type&quot;: &quot;select&quot;,  // 正则：必须包含 [pianyijichang]  &quot;filter&quot;: &quot;(?i)\\\\[pianyijichang\\\\]&quot;,   ...&#125;,// AI 专用策略组&#123;  &quot;name&quot;: &quot;AI&quot;,  &quot;type&quot;: &quot;url-test&quot;,  // 正则：必须包含 [AIjichang] 并且是 美国 节点  &quot;filter&quot;: &quot;(?i)\\\\[AIjichang\\\\].*(美国|US|United States)&quot;,   ...&#125;\n\n第三步：填补规则漏洞（关键！）很多规则集（Rule Provider）对 Google AI Studio 的覆盖并不完全。你会发现主页走了 AI 节点，但后台 API 请求（alkalimakersuite 等）却走了普通节点，导致跨区报错。\n需要在脚本的 myProxyRules 中手动补全这些“漏网之鱼”：\nconst myProxyRules = [  // 强制 Google AI Studio 后端走 AI 组  &quot;DOMAIN-KEYWORD,alkalimakersuite,AI&quot;,  &quot;DOMAIN-KEYWORD,developerprofiles,AI&quot;,  // 强制生成式 AI API  &quot;DOMAIN-SUFFIX,generativelanguage.googleapis.com,AI&quot;,  // 强制 Gemini/Bard  &quot;DOMAIN-SUFFIX,gemini.google.com,AI&quot;,  &quot;DOMAIN-SUFFIX,bard.google.com,AI&quot;];\n\n效果总结配置完成后，你的 Clash 面板将非常清爽：\n\n看 YouTube 自动走pianyijichang（台湾），速度快且省钱。\n一旦打开 aistudio.google.com 或调用 Gemini API，自动无感切换到 AIjichangCloud（美国），极其稳定。\n再也不用手动切来切去了！\n\n","categories":["technique","vpn"],"tags":["Blogs","vpn"]}]