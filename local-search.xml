<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Clash Verge 进阶玩法：双机场合并 + AI 专线精准分流指南</title>
    <link href="/2025/11/19/clashvergeDubleMerge/"/>
    <url>/2025/11/19/clashvergeDubleMerge/</url>
    
    <content type="html"><![CDATA[<hr><p><strong>背景需求：</strong><br>很多朋友手头都有两个机场订阅：</p><ol><li><strong>主力机场（如pianyijichang）：</strong> 流量大、便宜，台湾&#x2F;香港节点速度快，适合看 YouTube、Netflix 和日常冲浪。</li><li><strong>备用&#x2F;高端机场（如 AIjichangCloud）：</strong> 拥有原生 IP，能解锁各种 AI 限制，适合专门访问 Google AI Studio、Gemini、OpenAI。</li></ol><p><strong>痛点：</strong> 简单的合并订阅会导致节点混杂，如果不手动切换，AI 请求很容易走到台湾节点导致报错（如 Region not supported）。</p><p>今天分享一个在 <strong>Clash Verge (Rev)</strong> 中实现“双订阅合并 + 自动化分流”的完美方案。</p><hr><h3 id="第一步：创建本地配置，合并并标记节点"><a href="#第一步：创建本地配置，合并并标记节点" class="headerlink" title="第一步：创建本地配置，合并并标记节点"></a>第一步：创建本地配置，合并并标记节点</h3><p>要在脚本中区分两个机场，最稳妥的办法是在拉取订阅时给节点加上“前缀标签”。</p><p>新建一个 <strong>Local</strong> 类型的配置，使用 <code>proxy-providers</code> 引入订阅，并利用 <code>override</code> 功能强行加前缀：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">proxy-providers:</span><br>  <span class="hljs-comment"># 机场 A：主力流量</span><br>  <span class="hljs-attr">pianyijichang:</span><br>    <span class="hljs-attr">type:</span> <span class="hljs-string">http</span><br>    <span class="hljs-attr">url:</span> <span class="hljs-string">&quot;你的订阅链接&quot;</span><br>    <span class="hljs-attr">path:</span> <span class="hljs-string">./profiles/pianyijichang.yaml</span><br>    <span class="hljs-attr">override:</span><br>      <span class="hljs-attr">additional-prefix:</span> <span class="hljs-string">&quot;[pianyijichang]&quot;</span> <span class="hljs-comment"># 关键步骤：给它打上标签</span><br><br>  <span class="hljs-comment"># 机场 B：AI 专用</span><br>  <span class="hljs-attr">AIjichang:</span><br>    <span class="hljs-attr">type:</span> <span class="hljs-string">http</span><br>    <span class="hljs-attr">url:</span> <span class="hljs-string">&quot;你的订阅链接&quot;</span><br>    <span class="hljs-attr">path:</span> <span class="hljs-string">./profiles/AIjichang.yaml</span><br>    <span class="hljs-attr">override:</span><br>      <span class="hljs-attr">additional-prefix:</span> <span class="hljs-string">&quot;[AIjichang]&quot;</span>   <span class="hljs-comment"># 关键步骤：给它打上标签</span><br></code></pre></td></tr></table></figure><h3 id="第二步：使用脚本进行正则筛选"><a href="#第二步：使用脚本进行正则筛选" class="headerlink" title="第二步：使用脚本进行正则筛选"></a>第二步：使用脚本进行正则筛选</h3><p>在 Clash Verge 的 <strong>全局扩展脚本</strong> 中，利用正则表达式根据刚才的标签把节点分配给不同的策略组。</p><p><strong>核心逻辑：</strong></p><ul><li><strong>YouTube&#x2F;通用组</strong>：只允许名字里含 <code>[pianyijichang]</code> 的节点进入。</li><li><strong>AI 组</strong>：只允许名字里含 <code>[AIjichang]</code> 且含 <code>美国</code> 的节点进入。</li></ul><p>代码片段（修改 <code>config[&quot;proxy-groups&quot;]</code> 部分）：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// YouTube 或 通用 策略组</span><br>&#123;<br>  <span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;YouTube&quot;</span>,<br>  <span class="hljs-string">&quot;type&quot;</span>: <span class="hljs-string">&quot;select&quot;</span>,<br>  <span class="hljs-comment">// 正则：必须包含 [pianyijichang]</span><br>  <span class="hljs-string">&quot;filter&quot;</span>: <span class="hljs-string">&quot;(?i)\\[pianyijichang\\]&quot;</span>, <br>  ...<br>&#125;,<br><br><span class="hljs-comment">// AI 专用策略组</span><br>&#123;<br>  <span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;AI&quot;</span>,<br>  <span class="hljs-string">&quot;type&quot;</span>: <span class="hljs-string">&quot;url-test&quot;</span>,<br>  <span class="hljs-comment">// 正则：必须包含 [AIjichang] 并且是 美国 节点</span><br>  <span class="hljs-string">&quot;filter&quot;</span>: <span class="hljs-string">&quot;(?i)\\[AIjichang\\].*(美国|US|United States)&quot;</span>, <br>  ...<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="第三步：填补规则漏洞（关键！）"><a href="#第三步：填补规则漏洞（关键！）" class="headerlink" title="第三步：填补规则漏洞（关键！）"></a>第三步：填补规则漏洞（关键！）</h3><p>很多规则集（Rule Provider）对 Google AI Studio 的覆盖并不完全。你会发现主页走了 AI 节点，但后台 API 请求（<code>alkalimakersuite</code> 等）却走了普通节点，导致跨区报错。</p><p>需要在脚本的 <code>myProxyRules</code> 中手动补全这些“漏网之鱼”：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> myProxyRules = [<br>  <span class="hljs-comment">// 强制 Google AI Studio 后端走 AI 组</span><br>  <span class="hljs-string">&quot;DOMAIN-KEYWORD,alkalimakersuite,AI&quot;</span>,<br>  <span class="hljs-string">&quot;DOMAIN-KEYWORD,developerprofiles,AI&quot;</span>,<br>  <span class="hljs-comment">// 强制生成式 AI API</span><br>  <span class="hljs-string">&quot;DOMAIN-SUFFIX,generativelanguage.googleapis.com,AI&quot;</span>,<br>  <span class="hljs-comment">// 强制 Gemini/Bard</span><br>  <span class="hljs-string">&quot;DOMAIN-SUFFIX,gemini.google.com,AI&quot;</span>,<br>  <span class="hljs-string">&quot;DOMAIN-SUFFIX,bard.google.com,AI&quot;</span><br>];<br></code></pre></td></tr></table></figure><h3 id="效果总结"><a href="#效果总结" class="headerlink" title="效果总结"></a>效果总结</h3><p>配置完成后，你的 Clash 面板将非常清爽：</p><ul><li>看 YouTube 自动走pianyijichang（台湾），速度快且省钱。</li><li>一旦打开 aistudio.google.com 或调用 Gemini API，自动无感切换到 AIjichangCloud（美国），极其稳定。</li><li>再也不用手动切来切去了！</li></ul>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
      <category>网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Clash Verge</tag>
      
      <tag>机场订阅</tag>
      
      <tag>AI 分流</tag>
      
      <tag>网络代理</tag>
      
      <tag>科学上网</tag>
      
      <tag>教程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HEProOE: Hyperedge-Enhanced Spatial Community Detection Method</title>
    <link href="/2025/11/17/HEProOE/"/>
    <url>/2025/11/17/HEProOE/</url>
    
    <content type="html"><![CDATA[<p>Building upon our previous work with ProOE, we are thrilled to introduce the <strong>Hyperedge-Enhanced Probabilistic Optimal Estimation (HEProOE)</strong> method. This advanced model addresses a key limitation in mobility-based community detection: the fragmentation of large, semantically consistent areas. HEProOE integrates hyperedges to represent these “Indivisible Regions” (IRs), ensuring that the detected communities are not only structurally sound but also functionally coherent.</p><ul><li><strong>Paper:</strong> The full manuscript is currently in production.</li><li><strong>GitHub Repository:</strong> The data and code can be requested from me.</li></ul><hr><h3 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a><strong>Abstract</strong></h3><p>Identifying spatial communities with human mobility data has emerged as a key approach to understanding urban spatial structure. However, relying solely on human mobility data to partition spatial communities ignores the semantic information and may fragment large, semantic consistent Indivisible Regions (IRs) such as college campuses. Furthermore, individual spatial units often belong simultaneously to multiple IRs, creating membership uncertainty, while the spatial stochasticity of human movements inherently introduces ambiguity to the boundaries of spatial fuzzy communities. To address these challenges, we proposed the Hyperedge-Enhanced Probabilistic Optimal Estimation method (HEProOE) that integrated the hyperedge into spatial fuzzy community detection, representing IRs as semantic consistent regions. First, IRs were represented as hyperedges, where each spatial unit holds a probabilistic community membership. Second, a novel distance-weighted Jensen-Shannon (JS) divergence metric was introduced to measure the semantic consistency within each hyperedge. Finally, this metric was converted into a new likelihood component and seamlessly integrated with the mobility-based ProOE model, yielding a unified framework that simultaneously optimizes for both mobility patterns and semantic consistency. Experimental results demonstrated that HEProOE uncovers spatial fuzzy communities with significantly higher semantic consistency, providing an effective tool for a more authentic understanding of urban spatial structures.</p><hr><h3 id="The-Challenge-Beyond-Mobility-Patterns"><a href="#The-Challenge-Beyond-Mobility-Patterns" class="headerlink" title="The Challenge: Beyond Mobility Patterns"></a><strong>The Challenge: Beyond Mobility Patterns</strong></h3><p>While models like ProOE excel at identifying fuzzy communities from mobility data, they can sometimes break apart functionally unified areas—like a large university campus or a financial district—because the internal mobility patterns might not be perfectly uniform. These <strong>Indivisible Regions (IRs)</strong> have a strong semantic identity that should be preserved.</p><h3 id="The-HEProOE-Framework-Integrating-Semantics-with-Hyperedges"><a href="#The-HEProOE-Framework-Integrating-Semantics-with-Hyperedges" class="headerlink" title="The HEProOE Framework: Integrating Semantics with Hyperedges"></a><strong>The HEProOE Framework: Integrating Semantics with Hyperedges</strong></h3><p>HEProOE solves this by introducing <strong>hyperedges</strong>. In network science, a regular edge connects two nodes. A hyperedge can connect <em>multiple</em> nodes at once. We use hyperedges to model IRs, grouping all spatial units within a single functional zone (e.g., all the zones that make up “Midtown”).</p><p>This creates a unified probabilistic framework that balances two goals:</p><ol><li>Aligning with observed <strong>mobility patterns</strong> (the strength of ProOE).</li><li>Enforcing <strong>semantic consistency</strong> within known IRs (the new enhancement).</li></ol><p>The overall methodology is illustrated below.</p><p><img src="/2025/11/17/HEProOE/Figure1.png" alt="Figure 1. Illustration of the proposed Hyperedge-Enhanced Probabilistic Optimal Estimation method. The pie chart shows the spatial units&#39; membership to different communities. The colors represent different communities."></p><hr><h3 id="Study-Area-and-Data"><a href="#Study-Area-and-Data" class="headerlink" title="Study Area and Data"></a><strong>Study Area and Data</strong></h3><p>We again use <strong>New York City</strong> as our study area. The IRs (hyperedges) were sourced from OpenStreetMap, selecting 18 prominent, named regions like “Upper West Side” and “Lenox Hill.” The mobility data comes from over 8 million taxi trips.</p><p><img src="/2025/11/17/HEProOE/Figure2.png" alt="Figure 2. Overview of study area and data. (a) Overview of the research area. (b) Trip data for New York City. (c) IRs obtained from OpenStreetMap [Data © OpenStreetMap contributors; licensed under ODbL 1.0; openstreetmap.org/copyright]."></p><hr><h3 id="Key-Results-Semantically-Consistent-Communities"><a href="#Key-Results-Semantically-Consistent-Communities" class="headerlink" title="Key Results: Semantically Consistent Communities"></a><strong>Key Results: Semantically Consistent Communities</strong></h3><p>The integration of hyperedges leads to a significant improvement in the quality and interpretability of the detected communities.<br><img src="/2025/11/17/HEProOE/Figure3.png" alt="Figure 3. Detection result based on HEProOE. (a) Spatial fuzzy community. (b) Confidence Index (ConI). (c) Certainty Index (CerI)."></p><h4 id="Visual-Comparison-ProOE-vs-HEProOE"><a href="#Visual-Comparison-ProOE-vs-HEProOE" class="headerlink" title="Visual Comparison: ProOE vs. HEProOE"></a><strong>Visual Comparison: ProOE vs. HEProOE</strong></h4><p>The figure below shows a direct comparison between the communities detected by the original ProOE and the new HEProOE. While ProOE identifies a reasonable structure, it incorrectly splits the well-defined “Upper West Side” and “Upper East Side” regions. HEProOE, guided by the semantic hyperedges, correctly preserves the integrity of these large functional zones.<br><img src="/2025/11/17/HEProOE/Figure4.png" alt="Figure 4. Comparison between community detection results from (a) HEProOE, (b) ProOE, and (c) Hypergraph-MT"></p><h4 id="Quantitative-Evaluation"><a href="#Quantitative-Evaluation" class="headerlink" title="Quantitative Evaluation"></a><strong>Quantitative Evaluation</strong></h4><p>To provide a quantitative basis for our comparison, we measured the alignment between each model’s community partitions and the predefined Identified Regions (IRs) using Fuzzy Normalized Mutual Information (FNMI)30. The results are telling: HEProOE achieved the highest FNMI score (0.440), surpassing both ProOE (0.410) and Hypergraph-MT (0.312). This score confirms that our model’s partitions correspond most closely to the city’s established semantic geography, a finding corroborated by visual analysis.</p><p>By combining the strengths of probabilistic modeling with the structural integrity of hypergraphs, HEProOE provides a powerful and more authentic tool for understanding the complex fabric of our cities.</p>]]></content>
    
    
    <categories>
      
      <category>Research</category>
      
      <category>Methodology</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Community Detection</tag>
      
      <tag>Human Mobility</tag>
      
      <tag>Fuzzy theory</tag>
      
      <tag>Hypergraph</tag>
      
      <tag>Urban Computing</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ProOE: Detecting Spatial Fuzzy Communities with Probabilistic Estimation</title>
    <link href="/2025/04/05/ProOE/"/>
    <url>/2025/04/05/ProOE/</url>
    
    <content type="html"><![CDATA[<p>We are excited to introduce <strong>ProOE (Probabilistic Optimal Estimation)</strong>, a novel approach for detecting spatial fuzzy communities, as detailed in our recent publication in the <em>International Journal of Geographical Information Science</em>. This method provides a more nuanced understanding of urban structures by embracing the inherent fuzziness and heterogeneity of human movements.</p><p>You can find the full paper and the source code here:</p><ul><li><strong>Paper:</strong> <a href="https://doi.org/10.1080/13658816.2025.2483850">A Probabilistic Optimal Estimation Method for Detecting Spatial Fuzzy Communities</a></li><li><strong>GitHub Repository:</strong> <a href="https://github.com/HeXiao2001/ProOE">HeXiao2001&#x2F;ProOE</a></li></ul><hr><h3 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a><strong>Abstract</strong></h3><p>Urban areas comprise numerous spatial communities due to the frequent and limited range of human movements. Due to the partial spatial stochasticity of human movements, urban spatial communities are fuzzy and spatially heterogeneous. Existing spatial community detection strategies based on deterministic and globally uniform criteria fail to account for these characteristics. Therefore, this study presents a framework for detecting spatial fuzzy communities by transforming spatial fuzzy community detection into trip estimations between spatial units. We developed a probabilistic optimal estimation (ProOE) method to estimate trip volumes between spatial units by adjusting the probability of the membership of each unit in a spatial community. A trip intensity parameter was introduced for each community to adjust the estimated trip volumes. The distance decay effect (DDE) of human movement was then incorporated into the model, further improving the accuracy of community delineation for specific cities. Finally, spatial continuity guidance was incorporated into the solution algorithm, minimizing unnecessary community fragmentation. The experimental results demonstrate that ProOE outperforms existing methods, achieving an average improvement of 31.57% in accuracy while effectively capturing the ambiguity in the interplay between spatial units and communities. This study contributes to a more precise understanding of the spatial structures of cities.</p><hr><h3 id="A-Quick-Look-at-Existing-Methods"><a href="#A-Quick-Look-at-Existing-Methods" class="headerlink" title="A Quick Look at Existing Methods"></a><strong>A Quick Look at Existing Methods</strong></h3><p>Traditional spatial community detection methods often rely on deterministic and globally uniform criteria. However, these approaches fall short in capturing the fuzzy boundaries and spatial heterogeneity that characterize real-world urban movements.</p><h3 id="The-ProOE-Framework"><a href="#The-ProOE-Framework" class="headerlink" title="The ProOE Framework"></a><strong>The ProOE Framework</strong></h3><p>Our ProOE method reframes the problem by transforming community detection into a trip estimation task between spatial units. The core idea is to probabilistically estimate trip volumes by iteratively adjusting the membership probabilities of each spatial unit to every community.</p><p>The framework is illustrated below, showing how ProOE integrates spatial constraints and probabilistic estimation to delineate fuzzy communities.</p><p><img src="https://raw.githubusercontent.com/HeXiao2001/ProOE/main/Framework.jpg" alt="Figure 1: Framework of the proposed ProOE."></p><p>The core idea of the model is further detailed in the following illustration, which visualizes how membership probabilities are optimized.</p><p><img src="https://raw.githubusercontent.com/HeXiao2001/ProOE/main/Core4model.png" alt="Figure 2: Illustration of the core idea of the model."></p><hr><h3 id="Key-Results-Simulated-Real-World-Data"><a href="#Key-Results-Simulated-Real-World-Data" class="headerlink" title="Key Results: Simulated &amp; Real-World Data"></a><strong>Key Results: Simulated &amp; Real-World Data</strong></h3><p>To validate the effectiveness of ProOE, we conducted experiments on both simulated and real-world datasets.</p><h4 id="1-Performance-on-Simulated-Datasets"><a href="#1-Performance-on-Simulated-Datasets" class="headerlink" title="1. Performance on Simulated Datasets"></a><strong>1. Performance on Simulated Datasets</strong></h4><p>We first designed three distinct simulated datasets to rigorously test the model’s ability to handle key spatial characteristics: <strong>continuity</strong>, <strong>fuzziness</strong>, and <strong>heterogeneity</strong>.</p><p><img src="/2025/04/05/ProOE/Figure4.jpg" alt="Figure 3. Simulation experiment for spatial heterogeneity. (a) and (b) display the simulated data: (a) predefined communities and (b) simulated trips. (c)–(h) Show the spatial community detection results from six different methods applied to this dataset: (c) ProOE, (d) MT, (e) LPA, (f) Leiden, (g) CNM and (h) ASSU."></p><p>The results of various community detection methods on these datasets are visualized below. It is clear that traditional methods struggle to correctly identify community structures, especially in the presence of fuzzy boundaries and varied internal densities.</p><p><img src="/2025/04/05/ProOE/Figure5.jpg" alt="Figure 4. Simulation experiment for fuzziness. (a) and (b) display the simulated data: (a) predefined communities and (b) simulated trips. (c)–(h) Show the spatial community detection results from six different methods applied to this dataset: (c) ProOE, (d) MT, (e) LPA, (f) Leiden, (g) CNM and (h) ASSU."></p><p><img src="/2025/04/05/ProOE/Figure6.jpg" alt="Figure 5. Simulation experiment for continuity. (a) and (b) Display the simulated data: (a) Predefined communities and (b) simulated trips, blue indicates abnormally high values. (c)–(h) Show the spatial community detection results from six different methods applied to this dataset: (c) ProOE, (d) MT, (e) LPA, (f) Leiden, (g) CNM and (h) ASSU."></p><p>To quantify this, we used the <strong>Fuzzy Normalized Mutual Information (FNMI)</strong> metric, which measures the similarity between the detected fuzzy communities and the ground truth. A higher FNMI value indicates better accuracy. As shown below, ProOE consistently outperforms other state-of-the-art methods across all three datasets.</p><p><img src="/2025/04/05/ProOE/Figure7.jpg" alt="Figure 6. FNMI values of three simulated datasets for different methods."></p><hr><h4 id="2-Case-Study-New-York-City-Taxi-Trips"><a href="#2-Case-Study-New-York-City-Taxi-Trips" class="headerlink" title="2. Case Study: New York City Taxi Trips"></a><strong>2. Case Study: New York City Taxi Trips</strong></h4><p>We then applied ProOE to a real-world dataset of New York City taxi trips to explore urban mobility patterns. The study area focuses on Manhattan, a hub of intense and complex human movement.</p><p><img src="/2025/04/05/ProOE/Figure8.jpg" alt="Figure 7: Overview of the study area and data. (a) The research area. (b) Trip data for NYC. (c) Trip data for Manhattan."></p><p>The final community structure detected by ProOE reveals a clear and meaningful division of Manhattan. The detected communities correspond well with known functional zones, such as Midtown, Upper East Side, and the financial district in Lower Manhattan. The fuzzy boundaries between these communities highlight the transitional zones where urban functions blend.</p><p><img src="/2025/04/05/ProOE/Figure11.jpg" alt="Figure 8: Detection result based on our method. (a) Spatial fuzzy community. The colors represent different communities, and the opacity indicates the membership certainty of each spatial unit.. (b) Confidence Index (ConI). (c) Certainty Index (CerI)."></p><hr><h3 id="Demonstration-Video"><a href="#Demonstration-Video" class="headerlink" title="Demonstration Video"></a><strong>Demonstration Video</strong></h3><p>Check out this video demonstrating <a href="https://github.com/HeXiao2001/ProOE/issues/1">the evolution of spatial fuzzy communities in New York City</a>, generated using the ProOE method.</p><p>This work offers a powerful new lens for urban planners, geographers, and data scientists to analyze and understand the intricate spatial fabric of our cities. We welcome you to explore the code, run the demos, and contribute to this exciting area of research!</p>]]></content>
    
    
    <categories>
      
      <category>Research</category>
      
      <category>Methodology</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Community Detection</tag>
      
      <tag>Human Mobility</tag>
      
      <tag>Fuzzy theory</tag>
      
      <tag>Urban Computing</tag>
      
      <tag>Python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Clash 全局扩展脚本：智能控制网站代理访问</title>
    <link href="/2024/12/24/clash%E5%85%A8%E5%B1%80%E6%89%A9%E5%B1%95%E8%84%9A%E6%9C%AC%E9%98%B2%E6%AD%A2%E9%83%A8%E5%88%86%E7%BD%91%E7%AB%99%E4%BD%BF%E7%94%A8%E4%BB%A3%E7%90%86%E8%AE%BF%E9%97%AE/"/>
    <url>/2024/12/24/clash%E5%85%A8%E5%B1%80%E6%89%A9%E5%B1%95%E8%84%9A%E6%9C%AC%E9%98%B2%E6%AD%A2%E9%83%A8%E5%88%86%E7%BD%91%E7%AB%99%E4%BD%BF%E7%94%A8%E4%BB%A3%E7%90%86%E8%AE%BF%E9%97%AE/</url>
    
    <content type="html"><![CDATA[<p>这是对上篇博客的更新 <a href="https://hexiao2001.github.io/2024/12/02/clash%E8%AE%A2%E9%98%85%E8%A7%84%E5%88%99%E6%89%A9%E5%B1%95/">clash verge 订阅扩展规则，防止部分学术网站走代理</a>。<br>上篇博客中的解决方案存在一个问题：每个订阅都需要设置一次，为了更加方便地将设置应用到全部订阅中，可以在clash verge 全局扩展脚本中设置代码</p><p>步骤：</p><ol><li>打开clash verge </li><li>点击订阅，右键全局扩展配置，点击编辑文件<br><img src="/2024/12/24/clash%E5%85%A8%E5%B1%80%E6%89%A9%E5%B1%95%E8%84%9A%E6%9C%AC%E9%98%B2%E6%AD%A2%E9%83%A8%E5%88%86%E7%BD%91%E7%AB%99%E4%BD%BF%E7%94%A8%E4%BB%A3%E7%90%86%E8%AE%BF%E9%97%AE/image.png" alt="alt text"></li><li>将下方的代码替换进去</li><li>最后，请记得更新所有订阅以应用这项更改</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// Define main function (script entry) </span><br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">main</span>(<span class="hljs-params">config, profileName</span>) &#123;<br>  <span class="hljs-comment">// 根据名称排除节点</span><br>  config = <span class="hljs-title function_">removeNodeByName</span>(config, <span class="hljs-regexp">/[kK]onghwaguk/g</span>);<br><br>  <span class="hljs-comment">// 新增：为美国、台湾、新加坡节点创建 AI 代理组</span><br>  config = <span class="hljs-title function_">addAITestGroup</span>(config);<br>  <span class="hljs-comment">// 添加代理规则</span><br>  config = <span class="hljs-title function_">addProxyRules</span>(config);<br><br>  <span class="hljs-comment">// 添加直连规则</span><br>  config = <span class="hljs-title function_">addDirectRules</span>(config);<br><br>  <span class="hljs-keyword">return</span> config;<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">addAITestGroup</span>(<span class="hljs-params">config</span>) &#123;<br>  <span class="hljs-keyword">if</span> (!config[<span class="hljs-string">&#x27;proxy-groups&#x27;</span>] || !config.<span class="hljs-property">proxies</span>) <span class="hljs-keyword">return</span> config;<br><br>  <span class="hljs-comment">// 收集包含“美国”/“台湾”/“新加坡”关键词的节点</span><br>  <span class="hljs-keyword">const</span> aiNodes = config.<span class="hljs-property">proxies</span>.<span class="hljs-title function_">filter</span>(<span class="hljs-function"><span class="hljs-params">p</span> =&gt;</span><br>    p.<span class="hljs-property">name</span> &amp;&amp; <span class="hljs-regexp">/(美国|usa|united\s?states|台湾|taiwan|新加坡|singapore)/i</span>.<span class="hljs-title function_">test</span>(p.<span class="hljs-property">name</span>)<br>  ).<span class="hljs-title function_">map</span>(<span class="hljs-function"><span class="hljs-params">p</span> =&gt;</span> p.<span class="hljs-property">name</span>);<br><br>  <span class="hljs-keyword">const</span> groupIndex = config[<span class="hljs-string">&#x27;proxy-groups&#x27;</span>].<span class="hljs-title function_">findIndex</span>(<span class="hljs-function"><span class="hljs-params">g</span> =&gt;</span> g.<span class="hljs-property">name</span> === <span class="hljs-string">&#x27;AI代理组&#x27;</span>);<br>  <span class="hljs-keyword">if</span> (groupIndex !== -<span class="hljs-number">1</span>) &#123;<br>    config[<span class="hljs-string">&#x27;proxy-groups&#x27;</span>][groupIndex].<span class="hljs-property">proxies</span> = aiNodes;<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    config[<span class="hljs-string">&#x27;proxy-groups&#x27;</span>].<span class="hljs-title function_">push</span>(&#123;<br>      <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;AI代理组&#x27;</span>,<br>      <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;url-test&#x27;</span>,<br>      <span class="hljs-attr">proxies</span>: aiNodes,<br>      <span class="hljs-attr">url</span>: <span class="hljs-string">&#x27;http://www.gstatic.com/generate_204&#x27;</span>,<br>      <span class="hljs-attr">interval</span>: <span class="hljs-number">500</span><br>    &#125;);<br>  &#125;<br>  <span class="hljs-keyword">return</span> config;<br>&#125;<br><br><span class="hljs-comment">/***</span><br><span class="hljs-comment"> * 根据名称排除节点</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">removeNodeByName</span>(<span class="hljs-params">config, regExp</span>) &#123;<br>  config[<span class="hljs-string">&#x27;proxy-groups&#x27;</span>] = config[<span class="hljs-string">&#x27;proxy-groups&#x27;</span>].<span class="hljs-title function_">map</span>(<span class="hljs-function"><span class="hljs-params">it</span> =&gt;</span> &#123;<br>    it.<span class="hljs-property">proxies</span> = it.<span class="hljs-property">proxies</span>.<span class="hljs-title function_">filter</span>(<span class="hljs-function"><span class="hljs-params">name</span> =&gt;</span> !name.<span class="hljs-title function_">match</span>(regExp));<br>    <span class="hljs-keyword">return</span> it;<br>  &#125;);<br>  <span class="hljs-keyword">return</span> config;<br>&#125;<br><br><span class="hljs-comment">/***</span><br><span class="hljs-comment"> * 添加代理规则</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">addProxyRules</span>(<span class="hljs-params">config</span>) &#123;<br>  config.<span class="hljs-property">rules</span> = myProxyRules.<span class="hljs-title function_">concat</span>(config.<span class="hljs-property">rules</span>);<br>  <span class="hljs-keyword">return</span> config;<br>&#125;<br><br><span class="hljs-comment">/***</span><br><span class="hljs-comment"> * 添加直连规则</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">addDirectRules</span>(<span class="hljs-params">config</span>) &#123;<br>  config.<span class="hljs-property">rules</span> = myDirectRules.<span class="hljs-title function_">concat</span>(config.<span class="hljs-property">rules</span>);<br>  <span class="hljs-keyword">return</span> config;<br>&#125;<br><br><span class="hljs-comment">/***</span><br><span class="hljs-comment"> * 自定义代理规则</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">const</span> myProxyRules = [<br>  <span class="hljs-string">&quot;DOMAIN-SUFFIX,openai.com,AI代理组&quot;</span>,<br>  <span class="hljs-string">&quot;DOMAIN-SUFFIX,anthropic.com,AI代理组&quot;</span>,<br>  <span class="hljs-string">&quot;DOMAIN-KEYWORD,claude,AI代理组&quot;</span>,<br>  <span class="hljs-string">&quot;DOMAIN-KEYWORD,chatgpt,AI代理组&quot;</span>,<br>  <span class="hljs-string">&quot;DOMAIN-KEYWORD,generativelanguage,AI代理组&quot;</span>,<br>  <span class="hljs-string">&quot;DOMAIN-KEYWORD,arcgis,AI代理组&quot;</span>,<br>  <span class="hljs-string">&quot;DOMAIN-KEYWORD,google,AI代理组&quot;</span>,<br>];<br><br><span class="hljs-comment">/***</span><br><span class="hljs-comment"> * 自定义直连规则</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">const</span> myDirectRules = [<br><br>  <span class="hljs-string">&quot;DOMAIN-KEYWORD,pubmed,DIRECT&quot;</span>,<br>  <span class="hljs-string">&quot;DOMAIN-KEYWORD,springer,DIRECT&quot;</span>,<br>  <span class="hljs-string">&quot;DOMAIN-KEYWORD,ieee,DIRECT&quot;</span>,<br>  <span class="hljs-string">&quot;DOMAIN-KEYWORD,elsevier,DIRECT&quot;</span>,<br>  <span class="hljs-string">&quot;DOMAIN-KEYWORD,steam,DIRECT&quot;</span>,<br>  <span class="hljs-string">&quot;DOMAIN-KEYWORD,clarivate,DIRECT&quot;</span>,<br>  <span class="hljs-string">&quot;DOMAIN-KEYWORD,sciencedirect,DIRECT&quot;</span>,<br>  <span class="hljs-string">&quot;DOMAIN-KEYWORD,webofscience,DIRECT&quot;</span>,<br>  <span class="hljs-string">&quot;DOMAIN-KEYWORD,nature,DIRECT&quot;</span>,<br>  <span class="hljs-string">&quot;DOMAIN-KEYWORD,tandfonline,DIRECT&quot;</span>,<br>  <span class="hljs-string">&quot;DOMAIN-KEYWORD,taylorfrancis,DIRECT&quot;</span>,<br>  <span class="hljs-string">&quot;DOMAIN-KEYWORD,cherrystudio,DIRECT&quot;</span>,<br>  <span class="hljs-string">&quot;DOMAIN-KEYWORD,taylorandfrancis,DIRECT&quot;</span>,<br>  <span class="hljs-string">&quot;DOMAIN-KEYWORD,elsevier.com,DIRECT&quot;</span>,           <span class="hljs-comment">// 保持，即使它看起来像一个域名</span><br>  <span class="hljs-string">&quot;DOMAIN-KEYWORD,onlinelibrary.wiley.com,DIRECT&quot;</span>, <span class="hljs-comment">// 保持，即使它看起来像一个域名</span><br>  <span class="hljs-string">&quot;DOMAIN-KEYWORD,els-cdn.com,DIRECT&quot;</span>,            <span class="hljs-comment">// 保持，即使它看起来像一个域名</span><br>  <span class="hljs-string">&quot;DOMAIN-KEYWORD,tuchong.com,DIRECT&quot;</span>,            <span class="hljs-comment">// 保持，即使它看起来像一个域名</span><br>  <span class="hljs-string">&quot;DOMAIN-KEYWORD,dl.acm.org,DIRECT&quot;</span>,              <span class="hljs-comment">// 保持，即使它看起来像一个域名</span><br>  <span class="hljs-string">&quot;DOMAIN-KEYWORD,acm-prod.disqus.com,DIRECT&quot;</span>,    <span class="hljs-comment">// 保持，即使它看起来像一个域名</span><br>  <span class="hljs-string">&quot;DOMAIN-KEYWORD,readspeaker.com,DIRECT&quot;</span>,        <span class="hljs-comment">// 保持，即使它看起来像一个域名</span><br>  <span class="hljs-string">&quot;DOMAIN-KEYWORD,webofknowledge.com,DIRECT&quot;</span>,      <span class="hljs-comment">// 保持，即使它看起来像一个域名</span><br>  <span class="hljs-string">&quot;DOMAIN-KEYWORD,taylorfrancis.com,DIRECT&quot;</span>,      <span class="hljs-comment">// 保持，即使它看起来像一个域名</span><br>  <span class="hljs-string">&quot;DOMAIN-KEYWORD,tandfonline.com,DIRECT&quot;</span>,        <span class="hljs-comment">// 保持，即使它看起来像一个域名</span><br>  <span class="hljs-string">&quot;DOMAIN-KEYWORD,rp.tandfonline.com,DIRECT&quot;</span>,      <span class="hljs-comment">// 保持，即使它看起来像一个域名</span><br><br>];<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>technique</category>
      
    </categories>
    
    
    <tags>
      
      <tag>vpn</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Clash Verge 订阅规则扩展：避免学术网站走代理</title>
    <link href="/2024/12/02/clash%E8%AE%A2%E9%98%85%E8%A7%84%E5%88%99%E6%89%A9%E5%B1%95/"/>
    <url>/2024/12/02/clash%E8%AE%A2%E9%98%85%E8%A7%84%E5%88%99%E6%89%A9%E5%B1%95/</url>
    
    <content type="html"><![CDATA[<p>在校内访问学术网站是不需要代理的，如果通过代理的话每次都会弹出学校账户验证很麻烦，因此有必要将学术网站的访问设置为直连（即不通过代理）<br><img src="/2024/12/02/clash%E8%AE%A2%E9%98%85%E8%A7%84%E5%88%99%E6%89%A9%E5%B1%95/1.png" alt="__"><br>右键订阅点编辑规则–高级</p><p><img src="/2024/12/02/clash%E8%AE%A2%E9%98%85%E8%A7%84%E5%88%99%E6%89%A9%E5%B1%95/2.png" alt="__"><br>点击高级</p><p>将里面的代码替换为下面的代码就好了</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">prepend:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">&#x27;DOMAIN,tuchong.com,DIRECT&#x27;</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">&#x27;DOMAIN-SUFFIX,taylorandfrancis.com,DIRECT&#x27;</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">&#x27;DOMAIN,dl.acm.org,DIRECT&#x27;</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">&#x27;DOMAIN,acm-prod.disqus.com,DIRECT&#x27;</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">&#x27;DOMAIN-SUFFIX,sciencedirectassets.com,DIRECT&#x27;</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">&#x27;DOMAIN-SUFFIX,readspeaker.com,DIRECT&#x27;</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">&#x27;DOMAIN-SUFFIX,webofknowledge.com,DIRECT&#x27;</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">&#x27;DOMAIN-KEYWORD,pubmed,DIRECT&#x27;</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">&#x27;DOMAIN-KEYWORD,springer,DIRECT&#x27;</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">&#x27;DOMAIN-KEYWORD,ieee,DIRECT&#x27;</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">&#x27;DOMAIN-KEYWORD,elsevier,DIRECT&#x27;</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">&#x27;DOMAIN-KEYWORD,sciencedirect,DIRECT&#x27;</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">&#x27;DOMAIN-KEYWORD,nature,DIRECT&#x27;</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">&#x27;DOMAIN-KEYWORD,tandfonline,DIRECT&#x27;</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">&#x27;DOMAIN-SUFFIX,elsevier.com,DIRECT&#x27;</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">&#x27;DOMAIN-SUFFIX,edu.cn,DIRECT&#x27;</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">&#x27;DOMAIN-SUFFIX,webofscience.com,DIRECT&#x27;</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">&#x27;DOMAIN-SUFFIX,tandfonline.com,DIRECT&#x27;</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">&#x27;DOMAIN-SUFFIX,link.springer.com,DIRECT&#x27;</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">&#x27;DOMAIN-SUFFIX,onlinelibrary.wiley.com,DIRECT&#x27;</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">&#x27;DOMAIN-SUFFIX,sciencedirect.com,DIRECT&#x27;</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">&#x27;DOMAIN-SUFFIX,taylorfrancis.com,DIRECT&#x27;</span><br><span class="hljs-attr">append:</span> []<br><span class="hljs-attr">delete:</span> []<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>technique</category>
      
    </categories>
    
    
    <tags>
      
      <tag>vpn</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Matplotlib 绘制三维散点图与包围椭球及核密度分析</title>
    <link href="/2024/12/02/matplotlib%E7%BB%98%E5%88%B6%E4%B8%89%E7%BB%B4%E6%95%A3%E7%82%B9%E5%9B%BE/"/>
    <url>/2024/12/02/matplotlib%E7%BB%98%E5%88%B6%E4%B8%89%E7%BB%B4%E6%95%A3%E7%82%B9%E5%9B%BE/</url>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>我们在绘制三维散点时经常需要在一张图中描述：1.散点在空间中的分布状态；2.散点在空间不同维度的分布情况。<br>下面介绍一种：通过椭球描述散点在空间中的分布状态，并通过核密度曲线描述散点在空间不同维度的分布情况的方法。</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>导入必要的库，数据准备</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">from</span> scipy.stats <span class="hljs-keyword">import</span> gaussian_kde  <span class="hljs-comment"># 导入高斯核函数</span><br></code></pre></td></tr></table></figure><h2 id="创建3D图"><a href="#创建3D图" class="headerlink" title="创建3D图"></a>创建3D图</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">ax = plt.figure().add_subplot(projection=<span class="hljs-string">&#x27;3d&#x27;</span>)<br>data=[]<br></code></pre></td></tr></table></figure><h2 id="随机生成data"><a href="#随机生成data" class="headerlink" title="随机生成data"></a>随机生成data</h2><p>定义一个函数来生成数据</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">generate_data</span>(<span class="hljs-params">mean, std_dev</span>):<br>    <span class="hljs-keyword">return</span> np.random.normal(mean, std_dev, <span class="hljs-number">100</span>)<br>data.append(generate_data(<span class="hljs-number">0.8</span>, <span class="hljs-number">0.1</span>))<br>data.append(generate_data(<span class="hljs-number">15</span>, <span class="hljs-number">2</span>))<br>data.append(generate_data(<span class="hljs-number">60</span>, <span class="hljs-number">10</span>))<br></code></pre></td></tr></table></figure><h2 id="显示散点图的包围椭球"><a href="#显示散点图的包围椭球" class="headerlink" title="显示散点图的包围椭球"></a>显示散点图的包围椭球</h2><p>matplotlib中需要构造点阵以显示面，因此我们需要首先生成椭球面的XYZ坐标，然后绘制</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">draw_ellipsoid</span>(<span class="hljs-params">ax, data, color</span>):<br>    <span class="hljs-comment"># 计算椭球的中心</span><br>    center = np.mean(data, axis=<span class="hljs-number">1</span>)<br><br>    <span class="hljs-comment"># 计算椭球的半径</span><br>    radius = <span class="hljs-number">0.5</span> * (np.<span class="hljs-built_in">max</span>(data, axis=<span class="hljs-number">1</span>) - np.<span class="hljs-built_in">min</span>(data, axis=<span class="hljs-number">1</span>))<br><br>    <span class="hljs-comment"># 生成椭球的表面点</span><br>    u = np.linspace(<span class="hljs-number">0</span>, <span class="hljs-number">2</span> * np.pi, <span class="hljs-number">100</span>)<br>    v = np.linspace(<span class="hljs-number">0</span>, np.pi, <span class="hljs-number">100</span>)<br>    x = center[<span class="hljs-number">0</span>] + radius[<span class="hljs-number">0</span>] * np.outer(np.cos(u), np.sin(v))<br>    y = center[<span class="hljs-number">1</span>] + radius[<span class="hljs-number">1</span>] * np.outer(np.sin(u), np.sin(v))<br>    z = center[<span class="hljs-number">2</span>] + radius[<span class="hljs-number">2</span>] * np.outer(np.ones(np.size(u)), np.cos(v))<br><br>    <span class="hljs-comment"># 绘制椭球</span><br>    ax.plot_surface(x, y, z, color=color, alpha=<span class="hljs-number">0.2</span>)<br></code></pre></td></tr></table></figure><h2 id="显示散点在空间不同维度的分布情况"><a href="#显示散点在空间不同维度的分布情况" class="headerlink" title="显示散点在空间不同维度的分布情况"></a>显示散点在空间不同维度的分布情况</h2><p>matplotlib的官网实例中提到，可以采用zdir 字段实现2D内容在3D图上的绘制，这里实际上可以简单将zdir设置为2D图中“缺失的”那个维度，如下所示</p><p>在X-Z平面上绘制核密度估计图</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">draw_kde3d_X2XZ</span>(<span class="hljs-params">ax, data,  color</span>):<br>    kde = gaussian_kde(data)<br>    xs = np.linspace(np.<span class="hljs-built_in">min</span>(data), np.<span class="hljs-built_in">max</span>(data), <span class="hljs-number">100</span>)<br>    ys = kde(xs)<br>    ax.plot(xs, ys*<span class="hljs-number">10</span>, zs=<span class="hljs-number">0</span>, zdir=<span class="hljs-string">&#x27;y&#x27;</span>, color=color)<br></code></pre></td></tr></table></figure><p>在Y-Z平面上绘制核密度估计图</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">draw_kde3d_Y2YZ</span>(<span class="hljs-params">ax, data,  color</span>):<br>    kde = gaussian_kde(data)<br>    xs = np.linspace(np.<span class="hljs-built_in">min</span>(data), np.<span class="hljs-built_in">max</span>(data), <span class="hljs-number">100</span>)<br>    ys = kde(xs)<br>    ax.plot(xs,ys*<span class="hljs-number">100</span>,  zs=[<span class="hljs-number">1.2</span> <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(data))], zdir=<span class="hljs-string">&#x27;x&#x27;</span>, color=color)<br></code></pre></td></tr></table></figure><p>在Z-Y平面上绘制核密度估计图</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">draw_kde3d_Z2ZY</span>(<span class="hljs-params">ax, data,  color</span>):<br>    kde = gaussian_kde(data)<br>    xs = np.linspace(np.<span class="hljs-built_in">min</span>(data), np.<span class="hljs-built_in">max</span>(data), <span class="hljs-number">100</span>)<br>    ys = kde(xs)<br>    ax.plot(ys*<span class="hljs-number">80</span>,xs,  zs=<span class="hljs-number">0</span>, zdir=<span class="hljs-string">&#x27;x&#x27;</span>, color=color)<br></code></pre></td></tr></table></figure><p>其实这里zdir其实就是与要绘制的平面相垂直的坐标轴，zdir在这里起到“临时更换坐标轴”的作用。</p><p>全部代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">from</span> scipy.stats <span class="hljs-keyword">import</span> gaussian_kde<br></code></pre></td></tr></table></figure><h2 id="创建3D图-1"><a href="#创建3D图-1" class="headerlink" title="创建3D图"></a>创建3D图</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">ax = plt.figure().add_subplot(projection=<span class="hljs-string">&#x27;3d&#x27;</span>)<br>data=[]<br></code></pre></td></tr></table></figure><h2 id="随机生成data-1"><a href="#随机生成data-1" class="headerlink" title="随机生成data"></a>随机生成data</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">generate_data</span>(<span class="hljs-params">mean, std_dev</span>):<br>    <span class="hljs-keyword">return</span> np.random.normal(mean, std_dev, <span class="hljs-number">100</span>)<br>data.append(generate_data(<span class="hljs-number">0.8</span>, <span class="hljs-number">0.1</span>))<br>data.append(generate_data(<span class="hljs-number">15</span>, <span class="hljs-number">2</span>))<br>data.append(generate_data(<span class="hljs-number">60</span>, <span class="hljs-number">10</span>))<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">draw_ellipsoid</span>(<span class="hljs-params">ax, data, color</span>):<br>    <span class="hljs-comment"># 计算椭球的中心</span><br>    center = np.mean(data, axis=<span class="hljs-number">1</span>)<br>    <span class="hljs-comment"># 计算椭球的半径</span><br>    radius = <span class="hljs-number">0.5</span> * (np.<span class="hljs-built_in">max</span>(data, axis=<span class="hljs-number">1</span>) - np.<span class="hljs-built_in">min</span>(data, axis=<span class="hljs-number">1</span>))<br>    <span class="hljs-comment"># 生成椭球的表面点</span><br>    u = np.linspace(<span class="hljs-number">0</span>, <span class="hljs-number">2</span> * np.pi, <span class="hljs-number">100</span>)<br>    v = np.linspace(<span class="hljs-number">0</span>, np.pi, <span class="hljs-number">100</span>)<br>    x = center[<span class="hljs-number">0</span>] + radius[<span class="hljs-number">0</span>] * np.outer(np.cos(u), np.sin(v))<br>    y = center[<span class="hljs-number">1</span>] + radius[<span class="hljs-number">1</span>] * np.outer(np.sin(u), np.sin(v))<br>    z = center[<span class="hljs-number">2</span>] + radius[<span class="hljs-number">2</span>] * np.outer(np.ones(np.size(u)), np.cos(v))<br>    <span class="hljs-comment"># 绘制椭球</span><br>    ax.plot_surface(x, y, z, color=color, alpha=<span class="hljs-number">0.2</span>)<br></code></pre></td></tr></table></figure><h2 id="在X-Z平面上绘制核密度估计图"><a href="#在X-Z平面上绘制核密度估计图" class="headerlink" title="在X-Z平面上绘制核密度估计图"></a>在X-Z平面上绘制核密度估计图</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">draw_kde3d_X2XZ</span>(<span class="hljs-params">ax, data,  color</span>):<br>    kde = gaussian_kde(data)<br>    xs = np.linspace(np.<span class="hljs-built_in">min</span>(data), np.<span class="hljs-built_in">max</span>(data), <span class="hljs-number">100</span>)<br>    ys = kde(xs)<br>    ax.plot(xs, ys*<span class="hljs-number">10</span>, zs=<span class="hljs-number">0</span>, zdir=<span class="hljs-string">&#x27;y&#x27;</span>, color=color)<br></code></pre></td></tr></table></figure><h2 id="在Y-Z平面上绘制核密度估计图"><a href="#在Y-Z平面上绘制核密度估计图" class="headerlink" title="在Y-Z平面上绘制核密度估计图"></a>在Y-Z平面上绘制核密度估计图</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">draw_kde3d_Y2YZ</span>(<span class="hljs-params">ax, data,  color</span>):<br>    kde = gaussian_kde(data)<br>    xs = np.linspace(np.<span class="hljs-built_in">min</span>(data), np.<span class="hljs-built_in">max</span>(data), <span class="hljs-number">100</span>)<br>    ys = kde(xs)<br>    ax.plot(xs,ys*<span class="hljs-number">100</span>,  zs=[<span class="hljs-number">1.2</span> <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(data))], zdir=<span class="hljs-string">&#x27;x&#x27;</span>, color=color)<br></code></pre></td></tr></table></figure><h2 id="在Z-Y平面上绘制核密度估计图"><a href="#在Z-Y平面上绘制核密度估计图" class="headerlink" title="在Z-Y平面上绘制核密度估计图"></a>在Z-Y平面上绘制核密度估计图</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">draw_kde3d_Z2ZY</span>(<span class="hljs-params">ax, data,  color</span>):<br>    kde = gaussian_kde(data)<br>    xs = np.linspace(np.<span class="hljs-built_in">min</span>(data), np.<span class="hljs-built_in">max</span>(data), <span class="hljs-number">100</span>)<br>    ys = kde(xs)<br>    ax.plot(ys*<span class="hljs-number">80</span>,xs,  zs=<span class="hljs-number">0</span>, zdir=<span class="hljs-string">&#x27;x&#x27;</span>, color=color)<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">xyzlims=(<span class="hljs-number">0</span>, <span class="hljs-number">1.2</span>, <span class="hljs-number">0</span>, <span class="hljs-number">22</span>, <span class="hljs-number">0</span>, <span class="hljs-number">105</span>)<br></code></pre></td></tr></table></figure><p>绘制散点图<br>ax.scatter(data[0], data[1], data[2], c&#x3D;’g’, marker&#x3D;’*’, s&#x3D;10, label&#x3D;’data’)</p><p>绘制椭球</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">draw_ellipsoid(ax, data, <span class="hljs-string">&#x27;g&#x27;</span>)<br></code></pre></td></tr></table></figure><p>绘制X轴方向的核密度估计</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">draw_kde3d_X2XZ(ax, data[<span class="hljs-number">0</span>], <span class="hljs-string">&#x27;g&#x27;</span>)<br></code></pre></td></tr></table></figure><p>绘制Y轴方向的核密度估计</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">draw_kde3d_Y2YZ(ax, data[<span class="hljs-number">1</span>], <span class="hljs-string">&#x27;g&#x27;</span>)<br></code></pre></td></tr></table></figure><p>绘制Z轴方向的核密度估计</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">draw_kde3d_Z2ZY(ax, data[<span class="hljs-number">2</span>], <span class="hljs-string">&#x27;g&#x27;</span>)<br>ax.<span class="hljs-built_in">set</span>(xlim=(<span class="hljs-number">0</span>, <span class="hljs-number">1.2</span>), ylim=(<span class="hljs-number">0</span>, <span class="hljs-number">22</span>), zlim=(<span class="hljs-number">0</span>, <span class="hljs-number">105</span>))<br><span class="hljs-type">Set</span> zoom <span class="hljs-keyword">and</span> angle view<br>ax.view_init(<span class="hljs-number">20</span>, -<span class="hljs-number">35</span>, <span class="hljs-number">0</span>)<br>ax.set_box_aspect(<span class="hljs-literal">None</span>, zoom=<span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure><p>设置坐标轴的网格线颜色</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python">ax.xaxis.pane.set_edgecolor((<span class="hljs-number">1.0</span>, <span class="hljs-number">1.0</span>, <span class="hljs-number">1.0</span>, <span class="hljs-number">0.0</span>))<br>ax.yaxis.pane.set_edgecolor((<span class="hljs-number">1.0</span>, <span class="hljs-number">1.0</span>, <span class="hljs-number">1.0</span>, <span class="hljs-number">0.0</span>))<br>ax.zaxis.pane.set_edgecolor((<span class="hljs-number">1.0</span>, <span class="hljs-number">1.0</span>, <span class="hljs-number">1.0</span>, <span class="hljs-number">0.0</span>))<br>ax.set_xlabel(<span class="hljs-string">&#x27;X&#x27;</span>)<br>ax.set_ylabel(<span class="hljs-string">&#x27;Y&#x27;</span>)<br>ax.set_zlabel(<span class="hljs-string">&#x27;Z&#x27;</span>)<br>plt.show()<br></code></pre></td></tr></table></figure><h2 id="实现效果"><a href="#实现效果" class="headerlink" title="实现效果"></a>实现效果</h2><p><img src="/2024/12/02/matplotlib%E7%BB%98%E5%88%B6%E4%B8%89%E7%BB%B4%E6%95%A3%E7%82%B9%E5%9B%BE/%E6%95%88%E6%9E%9C%E5%9B%BE.png" alt="效果图"></p><h2 id="一点小改进"><a href="#一点小改进" class="headerlink" title="一点小改进"></a>一点小改进</h2><p>有些时候，我们可能有多种数据需要进行比较。这时，坐标系、网格等元素会对我们的展示造成干扰。因此，这里可以关闭这些内容的显示，并使用立方体表示三维空间。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">showbox</span>(<span class="hljs-params">data,ax</span>):  <br>    x, y, z = <span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>  <span class="hljs-comment">#盒子坐标</span><br>    dx, dy, dz = data  <span class="hljs-comment">#盒子长、宽、高</span><br>    ax.bar3d(x, y, z, dx, dy, dz, color=<span class="hljs-string">&quot;green&quot;</span>,zsort=<span class="hljs-string">&#x27;average&#x27;</span>,edgecolor=<span class="hljs-string">&#x27;black&#x27;</span>,linewidth=<span class="hljs-number">1</span>,alpha=<span class="hljs-number">0</span>)<br><br>···其他代码···<br></code></pre></td></tr></table></figure><p>设置坐标轴的背景颜色</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">ax.xaxis.pane.fill = <span class="hljs-literal">False</span><br>ax.yaxis.pane.fill = <span class="hljs-literal">False</span><br>ax.zaxis.pane.fill = <span class="hljs-literal">False</span><br></code></pre></td></tr></table></figure><p>设置坐标轴不可见</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">ax.axis(<span class="hljs-string">&#x27;off&#x27;</span>)<br>ax.grid(<span class="hljs-literal">False</span>)<br></code></pre></td></tr></table></figure><p>设置坐标轴的网格线颜色</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">ax.xaxis.pane.set_edgecolor((<span class="hljs-number">1.0</span>, <span class="hljs-number">1.0</span>, <span class="hljs-number">1.0</span>, <span class="hljs-number">0.0</span>))<br>ax.yaxis.pane.set_edgecolor((<span class="hljs-number">1.0</span>, <span class="hljs-number">1.0</span>, <span class="hljs-number">1.0</span>, <span class="hljs-number">0.0</span>))<br>ax.zaxis.pane.set_edgecolor((<span class="hljs-number">1.0</span>, <span class="hljs-number">1.0</span>, <span class="hljs-number">1.0</span>, <span class="hljs-number">0.0</span>))<br></code></pre></td></tr></table></figure><p>关闭坐标轴的刻度</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">ax.set_xticks([])<br>ax.set_yticks([])<br>ax.set_zticks([])<br>box = (<span class="hljs-number">1.2</span>,<span class="hljs-number">22</span>,<span class="hljs-number">105</span>)<br></code></pre></td></tr></table></figure><p>显示立方体</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">showbox(box,ax)<br>ax.set_xlabel(<span class="hljs-string">&#x27;X&#x27;</span>)<br>ax.set_ylabel(<span class="hljs-string">&#x27;Y&#x27;</span>)<br>ax.set_zlabel(<span class="hljs-string">&#x27;Z&#x27;</span>)<br>plt.show()<br></code></pre></td></tr></table></figure><h2 id="最终效果"><a href="#最终效果" class="headerlink" title="最终效果"></a>最终效果</h2><p><img src="/2024/12/02/matplotlib%E7%BB%98%E5%88%B6%E4%B8%89%E7%BB%B4%E6%95%A3%E7%82%B9%E5%9B%BE/%E6%9C%80%E7%BB%88%E6%95%88%E6%9E%9C%E5%9B%BE.png" alt="最终效果"></p>]]></content>
    
    
    <categories>
      
      <category>technique</category>
      
    </categories>
    
    
    <tags>
      
      <tag>plot</tag>
      
      <tag>python</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
